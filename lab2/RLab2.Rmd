---
title: "Rlab2"
author: "Alexey Volkov"
date: '18 октября 2018 г '
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Задание №1

```{r}
library(MASS)
data(Cars93)
```
 - Выполните команду summary() на полном наборе данных. Можно ли по результату выполнения сказать сколько строк в датафрейме? Если да, напишите сколько. Если нет, то приведите другой способ.

```{r}
summary(Cars93)
```

Можно подсчитать на основе полученной статистики по некоторым критериям, но напрямую информации нет. Например по критерию Origin видно, что всего строк 48+45=93 Или же AirBags 16+43+34=93. Есть специальная функция - nrow.

```{r}
nrow(Cars93)
```
  
 - Найдите среднюю цену машин с задним приводом.

```{r}
mean(Cars93$Price[Cars93$DriveTrain=="Rear"])
```

 - Найдите минимальное число лошадиных сил автомобиля для 7 пассажиров. Для 6 пассажиров.
 
```{r}
min(Cars93$Horsepower[Cars93$Passengers==7])
min(Cars93$Horsepower[Cars93$Passengers==6])
```

 - Найдите машины с максимальным, минимальным и средним(медианой) расстоянием, которая машина может проехать по трассе. Вам понадобятся 2 колонки, чтобы рассчитать расстояние. Какие?
 
```{r}
Cars93.MaxMiles <- Cars93$MPG.highway*Cars93$Fuel.tank.capacity

Cars93$Make[Cars93.MaxMiles == max(Cars93.MaxMiles)]
Cars93$Make[Cars93.MaxMiles == min(Cars93.MaxMiles)]
Cars93$Make[Cars93.MaxMiles == median(Cars93.MaxMiles)]
```

Нам понадобится объём бензобака и расход бензина на трассе

## Задание №2

В самом начале занятий приводился пример с фабрикой и производством автомобилей. Ниже приведён пример кода, который старается оптимизировать выпуск продукции ориентируясь на доступные ресурсы.

```{r}
factory.run <- function (o.cars=1, o.trucks=1) {
  factory <- matrix(c(40,1,60,3),nrow=2, dimnames=list(c("трудодни","сталь"),c("автомобили","грузовики")))
  warehouse <- c(1600,70) #Доступно материалов на складе
  names(warehouse) <- rownames(factory)
  reserve <- c(8,1)
  names(reserve) <- rownames(factory)
  output <- c(o.cars, o.trucks)
  names(output) <- colnames(factory)
  
  steps <- 0 # Счётчик числа шагов цикла
  repeat {
    steps <- steps + 1
    needed <- factory %*% output # Подсчитаем ресурсы, которые нам нужны для производства требуемого кол-ва машин
    message(steps)
    print(needed)
    # Если ресурсов достаточно и остаток меньше или равен резерву, то мы произвели максимум возможного.
    # Нужно прекращать
    if (all(needed <= warehouse) && all((warehouse - needed) <= reserve)) {
      break()
    }
    # Если заявка слишком большая и ресурсов недостаточно, уменьшим её на 10%
    if (all(needed > warehouse)) {
      output <- output * 0.9
      next()
    }
    # Если всё наоброт, то увеличим на 10%
    if (all(needed < warehouse)) {
      output <- output * 1.1
      next()
    }
    # Если мы потребили одного ресурса слишком много, а другого недостаточно,
    # то увеличим план на случайную величину
    output <- output * (1+runif(length(output),min=-0.1,max=0.1))
  }
  
  return(output)
}
```

 - Выполните код и запустите эту функцию factory.run()
 
```{r}
factory.run()
```

 - С каким входными значениями функция вызвана? Какой получился результат?

o.cars = 1 - 1 автомобиль, o.trucks = 1 - 1 грузовик. Результат получился 10 автомобилей и 19 грузовиков, оптимальное количество продукции при имеющихся ресурсах. Также указано количество шагов, за которое получилось достичь оптимального количества.
 
 - Повторите вызов 4 раза. Полученные ответы отличаются от полученных ранее? Если да, почему? Если нет, почему?
 
```{r, echo=FALSE}
run0<-factory.run()
run1<-factory.run()
run2<-factory.run()
run3<-factory.run()

all(run0==run1, run0==run2, run0==run3, run1==run2, run1==run3, run2==run3)
```
Полученные ответы отличаются, т.к. в функции задействована функция равномерного распределения, что привносит случайные величины в наш ход вычислений.

 - В приведённом коде, переменные steps и output находятся внутри алгоритма. Измените функцию так, чтобы она возвращала число шагов и произведённое количество машин.
 
```{r}
factory.run.v2 <- function (o.cars=1, o.trucks=1) {
  factory <- matrix(c(40,1,60,3),nrow=2, dimnames=list(c("трудодни","сталь"),c("автомобили","грузовики")))
  warehouse <- c(1600,70) #Доступно материалов на складе
  names(warehouse) <- rownames(factory)
  reserve <- c(8,1)
  names(reserve) <- rownames(factory)
  output <- c(o.cars, o.trucks)
  names(output) <- colnames(factory)
  
  steps <- 0 # Счётчик числа шагов цикла
  repeat {
    steps <- steps + 1
    needed <- factory %*% output # Подсчитаем ресурсы, которые нам нужны для производства требуемого кол-ва машин
    message(steps)
    print(needed)
    # Если ресурсов достаточно и остаток меньше или равен резерву, то мы произвели максимум возможного.
    # Нужно прекращать
    if (all(needed <= warehouse) && all((warehouse - needed) <= reserve)) {
      break()
    }
    # Если заявка слишком большая и ресурсов недостаточно, уменьшим её на 10%
    if (all(needed > warehouse)) {
      output <- output * 0.9
      next()
    }
    # Если всё наоброт, то увеличим на 10%
    if (all(needed < warehouse)) {
      output <- output * 1.1
      next()
    }
    # Если мы потребили одного ресурса слишком много, а другого недостаточно,
    # то увеличим план на случайную величину
    output <- output * (1+runif(length(output),min=-0.1,max=0.1))
  }
  result<-c(steps, output[["автомобили"]])
  names(result)<-c("Количество шагов", "Количество автомобилей")
  return(result)
}
```

 - Установите план равный 30 автомобилям и 20 грузовикам и выполните функцию.
 
```{r}
factory.run.v2(o.cars = 30, o.trucks = 20)
```
needed совпадает с результатами вызовов функций с начальными условиями (o.cars=1, o.trucks=1)
Но план не выполняется, т.к. готово только 10 автомобилей.
steps вариативен, в лучшем случае около 100-150 шагов, в среднем 200-400, в худшем больше 1000.


