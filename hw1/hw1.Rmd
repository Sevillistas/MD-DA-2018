---
title: "Homework 1"
author: "Alexey Volkov"
date: '26 декабря 2018'
output:
  html_document:
    df_print: paged
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Работа с данными

#### Загрузите данные в датафрейм, который назовите data.df

```{r}
data.df <- read.table("http://people.math.umass.edu/~anna/Stat597AFall2016/rnf6080.dat", header = TRUE)
```

#### Сколько строк и столбцов в data.df? Если получилось не 5070 наблюдений 27 переменных, то проверяйте аргументы.

```{r}
nrow(data.df)
ncol(data.df)
```

#### Получите имена колонок из data.df.

```{r}
colnames(data.df)
```

#### Найдите значение из 5 строки седьмого столбца.

```{r}
data.df[[5,7]]
```

#### Напечатайте целиком 2 строку из data.df

```{r}
data.df[2,]
```

#### Объясните, что делает следующая строка кода names(data.df) <- c("year", "month", "day", seq(0,23)).

```{r}
names(data.df)<- c("year", "month", "day", seq(0,23)) 
```

Именует столбцы в данном dataframe.

#### Воспользуйтесь функциями head и tail, чтобы просмотреть таблицу. Что представляют собой последние 24 колонки?

```{r}
head(data.df)
tail(data.df)
```

Последние 24 колонки представляют 24 часа в каждом наблюдаемом дне 

#### Добавьте новую колонку с названием daily, в которую запишите сумму крайних правых 24 колонок. Постройте гистограмму по этой колонке. Какие выводы можно сделать?

```{r}
data.df["daily"]<-rowSums(data.df[4:27])

hist(data.df$daily)
```

На гистограмме присутствуют отрицательные значения осадков за день

#### Создайте новый датафрейм fixed.df в котром исправьте замеченную ошибку. Постройте новую гистограмму, поясните почему она более корректна.

```{r}
fixed.df<-data.df[data.df$daily>=0,]
hist(fixed.df$daily)
```

Данная гистограмма корректна по сравнению с предыщущей, так как она не содержит отрицательных значений осадков за день.

## Синтаксис и типизирование

#### Для каждой строки кода поясните полученный результат, либо объясните почему она ошибочна.

v <- c("4", "8", "15", "16", "23", "42")
max(v)
sort(v)
sum(v)

```{r}
v <- c("4", "8", "15", "16", "23", "42")
```

Данная строка создаёт вектор строк

```{r}
max(v)
```

C помощью метода max() мы пытаемся получить наибольший элемент из вектора. Так как мы работаем со строками, а не с числами, то результат выполнения метода оказывается неверным с точки зрения ожидания пользователя.

```{r}
sort(v)
```

Ожидалось упорядочивание значений вектора по возрастанию/убыванию, но этого не произошло ввиду обработки нечислового типа данных.

```{r eval=FALSE, include=TRUE}
sum(v)
```

Данная строка кода не исполняется, так как sum не может быть применена к значения типа character.

```{r}
v<-as.integer(v)
```

После приведения значений вектора к типу integer все функции из прошлых примеров должны работать корректно.

```{r}
max(v)
sort(v)
sum(v)
```

#### Для следующих наборов команд поясните полученный результат, либо объясните почему они ошибочна.
 
v2 <- c("5",7,12)
v2[2] + 2[3]

df3 <- data.frame(z1="5",z2=7,z3=12)
df3[1,2] + df3[1,3]

l4 <- list(z1="6", z2=42, z3="49", z4=126)
l4[[2]] + l4[[4]]
l4[2] + l4[4]

```{r eval=FALSE, include=TRUE}
v2 <- c("5",7,12)
v2[2] + v2[3]
```

Вектор наполнен данными разных типов. В конечном счёте, они все приведены к типу данных character. Невозможно складывать characters с помощью оператора сложения.


```{r}
df3 <- data.frame(z1="5",z2=7,z3=12)
df3[1,2] + df3[1,3]
class(df3$z2)
```

В созданном dataframe колонки z2 и z3 являются numeric. z1 определён как factor. Выполнить сложение между двумя значениями типа numeric возможно.

```{r eval=FALSE, include=TRUE}
l4 <- list(z1="6", z2=42, z3="49", z4=126)
l4[[2]] + l4[[4]]
l4[2] + l4[4]
```

В случае l4[[]] мы работаем со значениями листа, вложенного в лист. В случае l4[] мы работаем с листом. Разумеется, что в первом случае возможна операция сложения, во втором - это невозможно.

## Работа с функциями и операторами

#### Оператор двоеточие создаёт последовательность целых чисел по порядку. Этот оператор — частный случай функции seq(), которую вы использовали раньше. Изучите эту функцию, вызвав команду ?seq. Испольуя полученные знания выведите на экран:

 - Числа от 1 до 10000 с инкрементом 372.

```{r}
seq(1, 10000, by = 372)
```

 - Числа от 1 до 10000 длиной 50.
 
```{r}
seq(1, 10000, length.out = 50)
```
 
#### Функция rep() повторяет переданный вектор указанное число раз. Объясните разницу между rep(1:5,times=3) и rep(1:5, each=3).

```{r}
rep(1:5,times=3)
rep(1:5, each=3)
```

rep times повторяет всю последовательность n раз, rep each повторяет каждое значение в последовательности n раз